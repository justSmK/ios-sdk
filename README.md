# TestAssignmentMindbox

### Задание

Напишите на swift код для поставки внешним клиентам, который позволяет вычислять площадь круга по радиусу и треугольника по трем сторонам. 

Дополнительно к работоспособности оценим:
- Юнит-тесты
- Легкость добавления других фигур
- Вычисление площади фигуры без знания типа фигуры в compile-time
- Проверку на то, является ли треугольник прямоугольным

### Реализация

Так как код нужен для поставки внешним клиентам, то проект создал как Framework. Протоколы фигур объявлены как public, чтобы их можно было реализовывать в других Target. 

Покрыл код Unti-тестами. `ShapeTests` отвечают за проверку вычисления площади фигуры без знания типа фигуры в compile-time. Реализовано вычисление площади без знания типа фигуры в compile-time при помощи протоколов, которые позволяют достигать полиморфного поведения. Предпочел структуры классам, так как преимущества в виде иммутабельности и потокобезопасности с производительностью в данном контексте выглядит лучше. Но также вполне можно реализовать фигуры как классы с модификатором доступа `open`, чтобы можно было в других таргетах их наследовать.

Добавлено свойство `var isRightAngled: Bool { get }` в `TriangleProtocol` для проверки, является ли треугольник прямоугольным.

~~Обе фигуры реализованы при помощи `Failable initializers`~~, так как круг не может существовать при минусовом радиусе, а треугольник с определенными сторонами также не может существовать.
Изменил `Failable initializers` на `init throws`, так как кажется удобнее получать ошибку и её вернуть пользователю, который сможет её обработать, чем просто вернуть nil.

Добавлен протокол `FormattableAreaProtocol` с дефолтной реализацией методов для вывода округленных значений до 2-х знаков после точки. Этот протокол также подписан на `ShapeProtocol` для того, чтобы в дефолтной реализации можно было использовать свойство `area`. 

Отказался от реализации Generic с использованием `FloatingPoint`, так как ассоциированные типы в протоколах сильно усложняют использование протоколов напрямую в качестве типов. Но можно с этим поработать при помощи ключевого слова `any` для обозначения экзистенциальный типов.

